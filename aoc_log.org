#+TITLE: Advent of Code – 2021 (Python)
#+AUTHOR: Leonardo Tamiano

* Day 12: Passage Pathing
  [2021-12-12 dom 21:27]

  L'idea è quella di effettuare la visita di un grafo. Come prima cosa
  quindi in entrambe le parti del problema dobbiamo scrivere il codice
  necessario per costruire il grafo a partire dall'input.

  Dato che l'input è formattato come segue

  #+begin_example
fs-end
he-DX
fs-he
start-DX
pj-DX
end-zg
  #+end_example
  
  Il codice python utilizzato per creare il grafo è il seguente

  #+begin_src python
def create_graph(lines):
    # NOTE: the graph is bi-directional    
    graph = {}

    for line in lines:
        splitted_l = line.split("-")
        node1, node2 = splitted_l[0].strip(), splitted_l[1].strip()

        # add edge 'node1 -> node2'
        if node1 not in graph:
            graph[node1] = [node2]
        else:
            graph[node1].append(node2)

        # add edge 'node2 -> node1'
        if node2 not in graph:
            graph[node2] = [node1]
        else:
            graph[node2].append(node1)        

    return graph
  #+end_src

  A questo punto andiamo a vedere gli algoritmi utilizzati per
  visitare il grafo per le due parti del problema.

** Parte 1
   Nella prima parte dobbiamo contare il numero di cammini che partono
   dal nodo ~start~ e arrivano al nodo ~end~. I cammini sono poi vincolati
   nel seguente modo: *i nodi con etichetta minuscola possono essere utilizzati una sola volta*.

   Se vogliamo solamente contare il numero di cammini troviamo quindi
   il seguente algoritmo

   #+begin_src python
def count_paths_part_1(graph, current_node, visited_small_caves):
    # -- base cases
    if current_node == 'end':
        return 1
    if current_node not in graph:
        return 0
    else:
        result = 0
        updated_visited_small_caves = visited_small_caves.copy()
        
        # -- visit current_node
        if current_node.islower():
            updated_visited_small_caves.add(current_node)

        # -- recurse on all of its neighbours
        for possible_node in graph[current_node]:
            # -- we can only go once for each lower-node
            if possible_node.islower() and possible_node not in updated_visited_small_caves:
                result += count_paths_part_1(graph, possible_node, updated_visited_small_caves)
            elif possible_node.isupper():
                result += count_paths_part_1(graph, possible_node, updated_visited_small_caves)

        return result
   #+end_src

   Se invece vogliamo anche stampare tutti i possibili cammini l'idea
   è quella di aggiungere un ulteriore argomento alla funzione per
   ottenere la seguente

   #+begin_src python
def enhanced_count_paths_part_1(graph, current_node, visited_small_caves, visited_nodes):
    # -- base cases
    if current_node == 'end':
        return 1
    if current_node not in graph:
        return 0
    else:
        result = 0

        updated_visited_small_caves = visited_small_caves.copy()
        # -- visit current_node
        if current_node.islower():
            updated_visited_small_caves.add(current_node)
        
        updated_visited_nodes = visited_nodes.copy()
        updated_visited_nodes.append(current_node)

        # -- visit all of its neighbours
        for possible_node in graph[current_node]:
            if possible_node.islower() and possible_node not in updated_visited_small_caves:
                result += enhanced_count_paths_part_1(graph, possible_node, updated_visited_small_caves, updated_visited_nodes)
            elif possible_node.isupper():
                result += enhanced_count_paths_part_1(graph, possible_node, updated_visited_small_caves, updated_visited_nodes)

        return result
   #+end_src

   ----------------

   La funzione finale è quindi la seguente

   #+begin_src python
def part_one():
    with open("input.txt", "r") as f:
        lines = f.readlines()
        # -- build graph structure by reading input
        graph = create_graph(lines)
        # -- visit the graph and count the paths
        result = count_paths_part_1(graph, "start", set())
        print(f"Result of part one: {result}")
   #+end_src
   
** Parte 2   
   La seconda parte ci chiede di contare tutti i cammini che
   soddisfano questo vincolo: *solo un nodo con etichetta minuscola
   diverso dal nodo di partenza e da quello di arrivo è utilizzato al
   massimo volte*. Il resto dei vincoli è rimasto invariato.

   L'idea è quindi quella di scrivere una funzione che calcola il
   numero di cammini in cui un certo nodo (~small_cave~) è visitato un certo numero
   di volte (~small_cave_count~).
 
   #+begin_src python
def count_paths_part_2(graph, current_node, visited_small_caves, small_cave, small_cave_count):
    # -- base cases
    if current_node == 'end':
        return int(small_cave_count == 0)
    elif current_node not in graph:
        return 0
    else:
        result = 0
        updated_visited_small_caves = visited_small_caves.copy()
        
        # -- visit current_node
        if current_node.islower():
            updated_visited_small_caves.add(current_node)

        # -- visit all of its neighbours
        for possible_node in graph[current_node]:
            if possible_node.islower():
                if possible_node == small_cave and small_cave_count > 0:
                    result += count_paths_part_2(graph, possible_node, updated_visited_small_caves, small_cave, small_cave_count - 1)
                elif possible_node not in updated_visited_small_caves:
                    result += count_paths_part_2(graph, possible_node, updated_visited_small_caves, small_cave, small_cave_count)
            elif possible_node.isupper():
                result += count_paths_part_2(graph, possible_node, updated_visited_small_caves, small_cave, small_cave_count)
        return result
   #+end_src

   Utilizzando questa funzione possiamo risolvere la seconda parte del
   problema nel seguente modo

   #+begin_src python
def part_two():
    graph = {}
    with open("input.txt", "r") as f:
        lines = f.readlines()

        # -- build graph structure by reading input
        graph = create_graph(lines)

        # -- visit the graph and count the paths
        final_res = 0        
        small_caves = [n for n in graph if n.islower() and n != 'start' and n != 'end']
        for cave in small_caves:
            final_res += count_paths_part_2(graph, "start", set(), cave, 2)
        final_res += count_paths_part_1(graph, "start", set())
        
        print(f"Result of part two: {final_res}")
   #+end_src

   Come possiamo vedere, calcoliamo il numero di percorsi in cui
   ciascun nodo minuscolo appare esattamente due volte, e poi
   calcoliamo il numero di percorsi utilizzando i vincoli di prima.

* Day 14: Extended Polymerization

** Try 1: Strings representation (failure)
   My first idea was to simply represent the entire polymer template
   as a sequence of characters and evolve the string using the
   particular rules given in the input.

   This approach is implemented as follows
   
   #+begin_src python
def better_evolve(template, rules):
    l = [f"{x}{y}" for (x, y) in zip(template, template[1:])]
    
    for i, prefix in enumerate(l):
        if prefix in rules:
            if i == len(l) - 1:
                l[i] = prefix[0] + rules[prefix] + prefix[1]
            else:
                l[i] = prefix[0] + rules[prefix]

    return "".join(l)
   #+end_src

   Where the input is read as such

   #+begin_src python
template = s_lines[0].strip()

rules = {}
for rule in s_lines[1].strip().split("\n"):
    s_rule = rule.split(" -> ")
    rules[s_rule[0]] = s_rule[1]
   #+end_src

   This approach however only works for the first part of the
   problem. For the second part the string simply becomes too big and
   it overflows the available memory.
   
** Try 2: Pairs representation (success)
   After failing the first try I tried another type of
   representation. The idea this time was to count the different
   number of pairs, and work on that representation when transforming
   from one template to another.

   To construct this representation we can use this function.

   #+begin_src python
def construct_pairs_representation(template, rules):
    unique_letters = "".join(list(set("".join(list(rules.keys())) + "".join(list(rules.values())) + "".join(list(template)))))
    
    # -- initialize pairs representation
    pairs = {}
    for x in itertools.permutations(unique_letters, 2):
        pairs["".join(x)] = 0
    for x in unique_letters:
        pairs[f"{x}{x}"] = 0

    for (x, y) in list(zip(template, template[1:])):
        pairs[f"{x}{y}"] += 1

    return pairs
   #+end_src

   We can then perform the template synthesis with this one

   #+begin_src python
def even_better_evolve(pairs, rules):
    new_pairs = {x:0 for x in pairs.keys()}
    
    # -- evolve pair representation
    for r in rules:
        if pairs[r] > 0:
            # -- we have a match
            # print(f"Found matching rule: {r} -> {rules[r]}")
            new_pairs[f"{r[0]}{rules[r]}"] += pairs[r]
            new_pairs[f"{rules[r]}{r[1]}"] += pairs[r]

    return new_pairs
   #+end_src

   And we can evaluate our answer with the following function. Note
   that in this function we count only the first letter for each
   pair. This is done to make sure that we don't doubly count the
   letters. Then we just have to add one to the final letter of the
   original template.

   #+begin_src python
def compute_result(template, pairs):
    unique_letters = set("".join(list(pairs.keys())))
    count = {l: 0 for l in unique_letters}
    
    for l in unique_letters:
        for p in pairs:
            if l == f"{p[0]}":
                count[l] += pairs[p]

    # The last letter never changes.
    count[template[-1]] += 1

    sorted_keys = list(count.keys())
    sorted_keys.sort(key=lambda x: count[x], reverse=True)
    
    return count[sorted_keys[0]] - count[sorted_keys[-1]]
   #+end_src

   Then the actual code for the challenge is shown below

   #+begin_src python
def part_two():
    with open("input.txt", "r") as f:
        s_lines = f.read().split("\n\n")

        # -- read input
        template = s_lines[0].strip()
        
        rules = {}
        for rule in s_lines[1].strip().split("\n"):
            s_rule = rule.split(" -> ")
            rules[s_rule[0]] = s_rule[1]

        pairs = construct_pairs_representation(template, rules)
        for i in range(0, 40):
            pairs = even_better_evolve(pairs, rules)

        result = compute_result(template, pairs)
        print(f"Solution to part one: {result}")
   #+end_src
